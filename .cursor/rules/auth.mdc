---
description: instructions for implementing GitHub OAuth authentication using AuthJS (NextAuth.js) in Next.js applications
alwaysApply: false
---

# GitHub OAuth with AuthJS and Session Management

This guide provides comprehensive instructions for implementing GitHub OAuth authentication using AuthJS (NextAuth.js) in Next.js applications, including database adapters, session management, and route protection.

## Setup Provider

### 1. Basic Auth.js Configuration

Enable GitHub as a sign-in option in your Auth.js configuration. In Next.js, set up your configuration in a file at the root of your repository.

**File: `auth.ts`**

```typescript
import NextAuth from "next-auth";
import GitHub from "next-auth/providers/github";

export const { handlers, signIn, signOut, auth } = NextAuth({
  providers: [GitHub],
});
```

### 2. API Route Setup

Add the `handlers` which NextAuth returns to your `api/auth/[...nextauth]/route.ts` file so that Auth.js can run on any incoming request.

**File: `app/api/auth/[...nextauth]/route.ts`**

```typescript
import { handlers } from "@/auth";
export const { GET, POST } = handlers;
```

## Sign-in Implementation

### Sign-in Button Component

Add a sign-in button in your application (e.g., Navbar) that triggers Auth.js sign-in when clicked.

**File: `components/sign-in.tsx`**

```typescript
import { signIn } from "@/auth";

export default function SignIn() {
  return (
    <form
      action={async () => {
        "use server";
        await signIn("github");
      }}
    >
      <button type="submit">Sign in with GitHub</button>
    </form>
  );
}
```

## Database Integration

### PostgreSQL Adapter

Database Adapters are the bridge used to connect Auth.js to your database.

**Installation:**

```bash
npm install @auth/pg-adapter pg
```

### Environment Variables

Set up the following environment variables:

```env
DATABASE_HOST=
DATABASE_NAME=
DATABASE_USER=
DATABASE_PASSWORD=
```

### Configuration

**File: `auth.ts`**

```typescript
import NextAuth from "next-auth";
import PostgresAdapter from "@auth/pg-adapter";
import { Pool } from "pg";

const pool = new Pool({
  host: process.env.DATABASE_HOST,
  user: process.env.DATABASE_USER,
  password: process.env.DATABASE_PASSWORD,
  database: process.env.DATABASE_NAME,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export const { handlers, auth, signIn, signOut } = NextAuth({
  adapter: PostgresAdapter(pool),
  providers: [],
});
```

### Neon Database (Edge Runtime)

If using Neon's PostgreSQL like Vercel Postgres, use `@neondatabase/serverless` for edge runtime compatibility.

**File: `auth.ts`**

```typescript
import NextAuth from "next-auth";
import PostgresAdapter from "@auth/pg-adapter";
import { Pool } from "@neondatabase/serverless";

// *DO NOT* create a `Pool` here, outside the request handler.
// Neon's Postgres cannot keep a pool alive between requests.

export const { handlers, auth, signIn, signOut } = NextAuth(() => {
  // Create a `Pool` inside the request handler.
  const pool = new Pool({ connectionString: process.env.DATABASE_URL });
  return {
    adapter: PostgresAdapter(pool),
    providers: [],
  };
});
```

## Database Schema

The SQL schema for the tables used by the PostgreSQL adapter:

```sql
CREATE TABLE verification_token
(
  identifier TEXT NOT NULL,
  expires TIMESTAMPTZ NOT NULL,
  token TEXT NOT NULL,
  PRIMARY KEY (identifier, token)
);

CREATE TABLE accounts
(
  id SERIAL,
  "userId" INTEGER NOT NULL,
  type VARCHAR(255) NOT NULL,
  provider VARCHAR(255) NOT NULL,
  "providerAccountId" VARCHAR(255) NOT NULL,
  refresh_token TEXT,
  access_token TEXT,
  expires_at BIGINT,
  id_token TEXT,
  scope TEXT,
  session_state TEXT,
  token_type TEXT,
  PRIMARY KEY (id)
);

CREATE TABLE sessions
(
  id SERIAL,
  "userId" INTEGER NOT NULL,
  expires TIMESTAMPTZ NOT NULL,
  "sessionToken" VARCHAR(255) NOT NULL,
  PRIMARY KEY (id)
);

CREATE TABLE users
(
  id SERIAL,
  name VARCHAR(255),
  email VARCHAR(255),
  "emailVerified" TIMESTAMPTZ,
  image TEXT,
  PRIMARY KEY (id)
);
```

## Authentication Functions

### Sign-in with Redirect

You can pass a provider to the `signIn` function for direct login, or redirect to a custom sign-in page.

```typescript
import { signIn } from "@/auth";

export function SignIn() {
  return (
    <form
      action={async () => {
        "use server";
        await signIn("github", { redirectTo: "/dashboard" });
      }}
    >
      <button type="submit">Sign in</button>
    </form>
  );
}
```

### Sign-out Implementation

**File: `app/components/signout-button.tsx`**

```typescript
import { signOut } from "@/auth";

export function SignOut() {
  return (
    <form
      action={async () => {
        "use server";
        await signOut();
      }}
    >
      <button type="submit">Sign Out</button>
    </form>
  );
}
```

## Session Management

### Getting User Session

Once a user is logged in, get the session object to access user data.

**File: `components/UserAvatar.tsx`**

```typescript
import { auth } from "../auth";

export default async function UserAvatar() {
  const session = await auth();

  if (!session?.user) return null;

  return (
    <div>
      <img src={session.user.image} alt="User Avatar" />
    </div>
  );
}
```

## Route Protection

### Server-Side Protection

Protect routes by checking for active sessions and redirecting unauthenticated users.

**File: `app/server/page.tsx`**

```typescript
import { auth } from "@/auth";

export default async function Page() {
  const session = await auth();
  if (!session) return <div>Not authenticated</div>;

  return (
    <div>
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  );
}
```

### Custom Pages

Enable custom authentication pages by adding the `pages` configuration to your Auth.js setup.

**File: `auth.ts`**

```typescript
import { NextAuth } from "next-auth";
import GitHub from "next-auth/providers/github";

export const config = {
  providers: [GitHub],
  pages: {
    signIn: "/login",
  },
};

export const { signIn, signOut, handle } = NextAuth(config);
```

## Middleware Integration

For additional route protection, you can integrate with Next.js middleware to check authentication status before requests reach your pages.

**File: `middleware.ts`**

```typescript
import { NextResponse, type NextRequest } from "next/server";
import { getToken } from "next-auth/jwt";

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  const token = await getToken({
    req: request,
    secret: process.env.AUTH_SECRET,
  });

  if (!token && pathname !== "/login") {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};
```

## Best Practices

1. **Environment Variables**: Always use environment variables for sensitive configuration
2. **Database Connections**: Create database connections inside request handlers for serverless environments
3. **Session Validation**: Always validate sessions on both client and server side
4. **Route Protection**: Implement middleware for consistent authentication checks
5. **Error Handling**: Provide clear error messages for authentication failures
6. **Security**: Use secure cookies in production environments
   }

export const { signIn, signOut, handle } = NextAuth(config)
